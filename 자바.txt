강사님 깃허브
https://github.com/Jiwoong-Jung/202407Java
lms페이지
choongang.atosoft.net
이클립스 패키지 평평하게 뜨면 위에 ... -> package presentation -> hierarchical

타입은 메모리에 저장되는 방식을 말한다.

btye타입끼리 연산을 할 때 int형으로 자동 변환되어 계산되기 때문에 결과는 int형으로 나온다.
byte b1 = 1;
byte b2 = 2;
byte b3 = (byte) b1+b2;

String 내장함수로 문자열을 반복해 붙여주는 repeat(int n)메서드가 있다.

자바에선 배열 생성시 자동 초기화

int scores[] = new int[] {83,90,87};
int scores2[] = {83,90,87};
두 문장은 같다.

Set<Integer> lottoSet = new HashSet<>();	//	중복을 허용하지 않는 Set 사용. <Integer>는 제네릭

System.out.printf("국어점수: %3.2f\n",score);	//	3은 확보할 공간의 자릿수, .2는 소수점 자릿수 지정

바이트 -> InputStream -> ObjectInputStream(역직렬화) -> 객체 -> ObjectOutputStream(직렬화) -> OutputStream -> 바이트

java.io.NotSerializableException : 직렬화 하지 않았을 때 발생하는 예외.

arraycopy("복사할 배열명", 복사 시작 인덱스, "붙여넣을 배열명", 붙여넣기 시작 인덱스, "복사할 문자 수");	// 배열복사

자료구조를 사용해 객체들을 효율적으로 추가 삭제 검색할 수 있도록 인터페이스와 구현 클래스를 java.util 패키지에서 제공하며 
이를 총칭해 컬렉션 프레임워크라 한다.

열거형(enum)은 상수만을 다루는 클래스이다.
enum 열거형 명{값1, 값2....값n} 으로 선언한다.

courses.contains(course)	// course가 courses에 존재하는지 확인

프로젝트 우클릭 > Build Path > Configure build path > library > classpath > add external jars로 라이브러리 임포트 가능

생성자는 특별한 메소드로, 반환타입이 존재하지 않음.

생성자가 다른 생성자를 호출 시 반드시 호출 먼저 해야한다.(this(), super()가 첫번째 줄)

this는 객체 자신에 대한 레퍼런스(참조)이다.

모든 클래스의 부모는 Object, 자식 클래스에서 인스턴스를 생성하기 위해서 부모 클래스의 생성자를 호출해야함(Object는 그 메소드를 사용하지
않으면 호출할 필요 없음)

인터페이스는 상수와 추상클래스만 소유 가능

인스턴스 멤버 클래스는 static 키워드없이 중첩 선언된 클래스를 의미

인스턴스는 클래스를 이용해 생성해야 사용 가능한 필드
정적 멤버는 static

자식 객체가 재정의된 메소드를 가지고 있으면, 부모 타입으로 자동 타입 변환 후에 메소드를 호출하면 재정의된 자식 메소드가 호출된다. = 다형성

인터페이스에서 필드는 무조건 public static final이다. 생략가능
인터페이스도 상속관계에서 일어나는 자동 타입 변환이 가능하다.
인터페이스간 상속은 implements가 아닌 extends이다. 그러므로 상속받은 인터페이스의 메소드를 구현할 필요가 없다. 또한 인터페이스간 다중상속이 가능
인터페이스를 익명객체로 사용시 즉시 구현하여 사용이 가능
plus.addActionListener(new ActionListener() { /* 구현 코드 */ });

에러는 고장, 예외는 사용자의 잘못된 조작 또는 개발자의 잘못된 코딩으로 인해 발생하는 프로그램 오류
예외는 발생 시점에 따라 일반 예외와 실행 예외로 나뉜다.
Class.forName()	// 이 클래스가 존재하는지 확인

중첩 클래스는 클래스명$중첩 클래스명.class 형태로 bin 파일에 저장된다.(A$B.class)
메소드 내에서 클래스를 선언하면 클래스명$1로컬클래스.class 형태로 저장된다.
로컬 클래스는 메소드 안에 선언된 클래스

인스턴스 멤버 클래스는 static 키워드 없이 중첩 선언된 클래스를 의미한다. 인스턴스 멤버 클래스는 인스턴스 필드와 메소드만 선언이 가능하고,
정적 필드와 메소드는 선언할 수 없다. 자바 17부턴 static 가능
일반적으로 A(외부 클래스)에서 B(내부 클래스) 객체를 생성하는 일은 거의 없다. 대부분 A(외부 클래스) 내부에서 B(내부 클래스) 객체를 생성해 사용한다.

프로세서(CPU)
프로세스(실행중인 프로그램)
멀티 프로세스 -> 리눅스, 유닉스, 과거 윈도우즈에선 불가능했다.
스레드(프로세스 내부에서 

String sql = String.format("insert into dept value(%d, '%s', '%s')", deptno, dname, loc);	// format함수로 문자열에 변수를 넣어 문자열로 만들 수 있음.

로컬 스레드는 메소드를 실행하는 스레드와 다르므로 메소드가 종료된 후에도 로컬 스레드 객체는 실행 상태로 존재할 수 있다.
이를 해결하기 위해 컴파일시 로컬 클래스에서 사용하는 매개 변수나 로컬 변수의 값을 로컬 클래스 내부에 복사해두고 사용한다. 그러므로 매개 변수나
로컬 변수가 수정되어 값이 변경되면 로컬 클래스에 복사해둔 값과 달라지므로 이를 해결하기 위해 final로 선언할 것을 요구한다.

final 특성을 가진 매개 변수나 로컬 변수만 로컬 클래스 내부에서 사용할 수 있다. 자바8 이후부턴 매개 변수와 로컬 변수는 final로 자동 치환된다.

로컬 클래스에서 외부 클래스의 필드를 사용하려면 외부클래스명.this.필드명 으로 호출한다.

람다식은 (매개변수)->{메서드구현코드} 으로 사용하며, 인터페이스에서만 가능하고 구현하는 메서드가 하나여야 한다.(함수형 인터페이스)
@FunctionalInterface를 인터페이스 위에 붙이면 이상이 있을시 오류를 띄워준다. 추상 클래스의 형태에 따른 리턴값과 매개변수를 가진다. 
람다식은 매개변수가 하나일시 소괄호 생략가능. 구현코드가 한줄일 시에 중괄호 생략가능.(return문일 경우 생략 불가능)
람다식 이용시 메소드 참조를 이용해 코드를 줄일 수 있다. 메소드 참조는 ::

표준 API(Application Programming Interface)
함수적 인터페이스
Consumer: 매개값O, 반환값X
Supplier: 매개값X, 반환값O
Function: 매개값 -> 리턴값으로 타입 변환
Operator: 매개값 -> 리턴값으로 값 연산
Predicate: 매개값 -> true/false로 리턴	

SOLID 설계 원칙
단일 책임 원칙: 객체는 단 하나의 책임만 가져야함
개방 폐쇠 원칙: 기존 코드를 변경하지 않으면서 기능을 추가할 수 있어야 함
ㄴ 기존 것을 수정할 시 다른 코드들에 영향이 가기 때문
리스코프 치환 원칙: 부모 클래스와 자식 클래스 사이의 행위가 일관성이 있어야 함
의존 역전 원칙: 의존관계를 맺을 때 변화하기 어려운 것에 의존해야 한다
인터페이스 분리 원칙: 인터페이스를 클라이언트에 특화되도록 분리해야 한다

자바의 구조 디자인 패턴
반복자 Iterator<E> / Iterable<E>: 컬렉션의 요소들의 기본 표현을 노출하지 않고 하나씩 모두를 순회할 수 있는 디자인 패턴
Adapter: 호환되지 않는 인터페이스를 가진 객체들이 협업할 수 있도록 하는 구조적 디자인 패턴
TemplateMethod: 부모 클래스에 대략적인 틀을 정의해놓고 자식 클래스로 자세한 사항을 구현하는 디자인 패턴
Singleton: 하나의 인스턴스만 갖는 클래스를 제공하는 디자인 패턴

익명 자식객체는 new 클래스()에 {}를 붙이면 생성된다. 익명 자식 객체는 부모 타입 변수에 대입되므로 익명 자식 객체에서 새로 정의된 필드와 
메소드는 내부에서만 사용 가능하다. 보통 필드나 메소드를 재정의하는데 사용한다.
인터페이스도 가능하며 이를 익명 구현 객체라고 한다.

예외는 Exception을 상속받아 만들며 throw로 예외 발생 가능. 런타임 익셉션을 throw하는 메소드는 try catch문으로 감쌀 필요 없음.

문자열 리터럴이 같은 변수가 여러개 있으면 모두 같은 주소를 가져 같은 공간을 가리키게 된다.
리터럴이란 프로그램에서 값을 직접 표현한 고정된 값이다.

A instanceof B는 A 객체가 B로 형변환 될 수 있는지 확인한다.

HashMap은 Key와 Value가 짝을 이루는 구조를 갖고있다.

Arrays, Comparator, Collections

SimpleDateFormat	// 날짜 포맷을 설정
DateTimeFormatter.ofPattern("yyyy-MM-dd hh:mm:ss").format(LocalDateTime.now());
날짜와 시간을 지정한 형식으로 출력; ex) 2024-07-30 15:26:03
javaScript는 스레드가 안됨

임계 영역(critical section)은 둘 이상의 스레드가 동시에 접근해서는 안되는 코드 영역을 뜻한다.
락은 임계 영역을 포함하고 있는 객체에 접근할 수 있는 권한을 의미한다.
자바는 임계 영역을 지정하기 위해 동기화(Synchronized) 메소드를 제공한다.

<? super T>는 자식클래스 T와 연관이 있는 부모 클래스는 전부 적용되는 것이다(매개변수로 허용)
<? extends T>는 부모클래스 T와 연관이 있는 자식 클래스는 전부 적용되는 것이다(매개변수로 허용)
함수적 인터페이스 Consumer는 매개변수만 받고 리턴값이 없다.
메소드 참조는 static, 인스턴스 메소드만 가능하며 인터페이스에만 사용가능하다.
인터페이스의 추상메소드는 메소드 참조 또는 람다식으로 구현 가능하며, 메소드 참조는 매개변수도 생략한다.

Map.Entry를 이용하면 Map에 저장된 모든 키-값의 쌍을 각각 하나씩 갖고있는 하나의 객체를 얻을 수 있다.

var는 JDK 21부터 사용할 수 있는 지역 변수 타입을 추론해 컴파일시 자동으로 변환되는 타입이다.
텍스트 블록은 JDK 13부터 사용할 수 있으며, """ ~내용~ """으로 선언하며 블록 내의 내용을 전부 그대로 삽입할 수 있다.(이스케이프 문자 등)
switch문의 표현식
ㄴ 단일값 리턴	// yield로 리턴값 설정
ㄴ null 매칭	// case null -> {}
ㄴ 타입 매칭	// case Integer i -> {} 처럼 타입을 명시할 수 있다.
중첩클래스의 정적멤버 허용
instanceof의 자동타입 변환

Set은 중복이 없는 List
Arrays.asList() 메소드로 포장클래스를 List타입으로 변환 가능, 또는 배열값을 직접 입력
객체 배열은 Arrays.sort를 사용하며, 컬렉션은 Collections.sort를 사용해 정렬한다.

//////////////////// 스트림 ////////////////////

스트림은 람다를 활용해 배열과 컬렉션을 함수형으로 간단하게 처리할 수 있는 기술이다.
스트림을 이용하면 선언형으로 컬렉션 데이터를 처리할 수 있다. 스트림의 구조는 크게 스트림생성>중개연산>최종연산으로 나뉜다.
filter 메소드는 매개변수를 받고 조건을 걸어 참인 경우의 데이터를 스트림 형태로 반환한다.
mapToInt( ToIntFunction<? super T> mapper ) 는 스트림을 Int스트림으로 변환한다.
limit(최대크기)	// 최대크기만큼의 데이터만 반환한다.

forEach( Consumer<? super T> action)는 받은 스트림만큼 반복한다. Consumer 인터페이스를 구현해야 한다. 람다식을 이용한다.
count메소드는 스트림의 데이터 개수를 long 형태로 반환한다.
IntStream은 range(x, y)로 x부터 y-1까지 값 반환, rangeClosed는 x부터 y까지 값을 반환한다.
스트림은 바깥 지역 변수를 변경할 수 없다.

Optional<T>는 T와 Null값을 감싸는 포장 클래스이며, NullPointerException을 방지하는 것을 도와준다.
isPresent()	// 값이 null이 아니면 true를 반환
ifPresent(구현메소드)	// 값이 null이 아니면 구현 메소드의 매개변수로 전달
orElse(대체값)	// null일시 대체값으로 null을 대체

//////////	//////////

이터레이터(자바 디자인 패턴 = 객체지향 코딩 패턴) = 반복자

Iterator<String> it = list.iterator();
		while(it.hasNext()) {
			String str = it.next();
			System.out.println(str);
		}


보통 데이터 순회에는 iterator, 데이터 생성 및 가공은 stream이 유리하다.

//////////////////// 파일처리 및 입출력 스트림 ////////////////////

File 객체는 new File("경로")로 생성한다.
mkdir()	// 폴더 생성
exist()	// 파일 존재여부를 반환(boolean)
createNewFile()	// 파일 생성

자바에서 데이터는 스트림을 통해 입출력 된다. 입출력 스트림에는 1. 바이트(1바이트) 기반 스트림과 2. 문자(2바이트) 기반 스트림이 있다.
바이트 기반 스트림은 XxxInputStream, XxxOutputStream 객체를 사용한다.
문자 기반 스트림은 XxxReader, XxxWriter 객체를 사용한다.
파일을 쓰기 위해서는 new FileWriter(경로(=파일))로 writer객체를 생성하여 사용한다

write("문자열")	// writer객체가 가리키는 파일에 문자열 쓰기
write(데이터, 시작인덱스, 데이터개수)	// 데이터를 시작인덱스부터 데이터개수만큼 쓰기
flush()	// 버퍼에 잔류된 데이터를 모두 출력
close()	// 메모리 반환(사용 종료)

파일을 읽기 위해서는 new FileReader("경로")로 reader객체를 생성하여 사용한다
read()	// reader객체가 가리키는 파일을 한 바이트씩 읽는다.
read(Buffer)	// 파일을 버퍼 크기만큼 읽어 버퍼에 저장하며, 읽은 데이터의 수를 반환한다.
close()

파일의 경로와 관련된 Path 객체가 있다.
Path객체의 생성은 Paths.get(경로)로 생성한다.
toFile()로 해당 객체의 경로를 가진 파일객체를 생성할 수 있다.

Files.lines(경로, 버퍼)	// 파일 한 줄씩 끊어 스트림<문자열>으로 반환한다.

BuffueredReader는 버퍼를 이용해 파일을 읽는 객체이며, 매개변수로 Reader를 받는다.
